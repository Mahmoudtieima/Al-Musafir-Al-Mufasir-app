<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿßŸÑŸÖÿ≥ÿßŸÅÿ± ÿßŸÑŸÖŸÅÿ≥ÿ± | Tadabbur Al-Qur'an</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Almarai:wght@400;700&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            direction: rtl;
            background-color: #f1f5f9;
        }
        .arabic-text, .arabic-heading, .arabic-input {
            font-family: 'Almarai', serif;
        }
        .rtl-content { direction: rtl; }
        .ltr-content { direction: ltr; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .gemini-content { text-align: left; }
        .gemini-content.ltr-content { direction: ltr; }
        .gemini-content.rtl-content { direction: rtl; text-align: right; }
        .gemini-content h1 { font-size: 1.5rem; font-weight: 700; margin-top: 1.5rem; margin-bottom: 1rem; color: #1e3a8a; border-bottom: 2px solid #cbd5e1; padding-bottom: 0.5rem; }
        .gemini-content h2 { font-size: 1.25rem; font-weight: 700; margin-top: 1.25rem; margin-bottom: 0.75rem; color: #1e40af; }
        .gemini-content h3 { font-size: 1.125rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; color: #1e3a8a; }
        .gemini-content h4 { font-size: 1rem; font-weight: 600; margin-top: 0.75rem; margin-bottom: 0.5rem; color: #1d4ed8; }
        .gemini-content p { margin-bottom: 1rem; line-height: 1.6; }
        .gemini-content strong { font-weight: 700; color: #1e293b; }
        .gemini-content em { font-style: italic; color: #475569; }
        .gemini-content ul, .gemini-content ol { margin-bottom: 1rem; padding-left: 1.5rem; }
        .gemini-content.rtl-content ul, .gemini-content.rtl-content ol { padding-right: 1.5rem; padding-left: 0; }
        .gemini-content ul { list-style-type: disc; }
        .gemini-content ol { list-style-type: decimal; }
        .gemini-content li { margin-bottom: 0.5rem; line-height: 1.6; }
        .gemini-content code { background-color: #f1f5f9; color: #e11d48; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.875em; font-family: 'Courier New', monospace; }
        .gemini-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin-bottom: 1rem; }
        .gemini-content pre code { background-color: transparent; color: inherit; padding: 0; }
        .gemini-content a { color: #0284c7; text-decoration: underline; transition: color 0.2s; }
        .gemini-content a:hover { color: #0369a1; }
        .nav-arrow { background: none; border: none; font-size: 2.5rem; color: #94a3b8; cursor: pointer; transition: color 0.2s; }
        .nav-arrow:hover { color: #334155; }
        .nav-arrow:disabled { color: #e2e8f0; cursor: not-allowed; }
        .lang-btn { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; color: #64748b; cursor: pointer; transition: all 0.2s; }
        .lang-btn:first-child { border-radius: 0 0.5rem 0.5rem 0; }
        .lang-btn:last-child { border-radius: 0.5rem 0 0 0.5rem; }
        .lang-btn.active-lang { background-color: #0284c7; color: white; border-color: #0284c7; }
        .model-btn { background-color: transparent; color: #64748b; border: none; cursor: pointer; }
        .model-btn.active-model { background-color: #0284c7; color: white; }
        .model-btn:hover:not(.active-model) { background-color: #e2e8f0; color: #334155; }
    </style>
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        
        <header class="text-center mb-6">
            <h1 class="arabic-heading text-4xl md:text-5xl text-slate-900">
                <span>ÿßŸÑŸÄ</span><span class="text-sky-600">ŸÖÿ≥ÿßŸÅÿ±</span><span> ÿßŸÑŸÄ</span><span class="text-sky-600">ŸÖŸÅÿ≥ÿ±</span>
            </h1>
            <p class="text-lg text-slate-600 mt-2 ltr-content tracking-wider text-center">The Traveller, The Interpreter</p>
        </header>

        <div id="lang-selector" class="flex justify-center mb-6">
            <button id="lang-en" class="lang-btn active-lang">English</button>
            <button id="lang-ar" class="lang-btn">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</button>
        </div>

        <main class="bg-white rounded-2xl shadow-lg p-6 md:p-8 min-h-[400px] mb-24">
            
            <div id="loading-state" class="hidden text-center">
                <div class="loader"></div>
                <p class="text-slate-500" data-lang-key="loadingQuran"></p>
            </div>
            
            <div id="error-state" class="hidden text-center p-8 bg-red-50 text-red-700 rounded-lg">
                <h3 class="font-bold text-lg mb-2" data-lang-key="connectionError"></h3>
                <p data-lang-key="connectionErrorMsg"></p>
            </div>

            <div id="app-content">
                <!-- Verse Selection -->
                <div class="flex flex-col md:flex-row gap-4 mb-8 rtl-content">
                    <div class="flex-1"><label for="surah-select" class="block mb-2 text-sm font-medium text-slate-700" data-lang-key="selectSurah"></label><select id="surah-select" class="w-full bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block p-2.5"></select></div>
                    <div class="flex-1"><label for="verse-select" class="block mb-2 text-sm font-medium text-slate-700" data-lang-key="selectVerse"></label><select id="verse-select" class="w-full bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block p-2.5"></select></div>
                </div>
                
                <div id="basmalah-display" class="hidden text-center mb-4">
                    <p class="arabic-text text-2xl text-slate-600">ÿ®Ÿêÿ≥ŸíŸÖŸê ÿßŸÑŸÑŸëŸéŸáŸê ÿßŸÑÿ±ŸëŸéÿ≠ŸíŸÖŸéŸ∞ŸÜŸê ÿßŸÑÿ±ŸëŸéÿ≠ŸêŸäŸÖŸê</p>
                </div>

                <div class="flex items-center justify-between gap-2 mb-8"><button id="prev-verse-btn" class="nav-arrow" aria-label="Previous Verse">&lt;</button><div class="p-6 bg-slate-50 rounded-xl border border-slate-200 min-h-[100px] flex flex-col items-center justify-center w-full"><p id="arabic-verse" class="arabic-text text-3xl md:text-4xl text-center leading-relaxed text-slate-900"></p><p id="english-verse" class="ltr-content text-center italic text-slate-600 mt-4"></p></div><button id="next-verse-btn" class="nav-arrow" aria-label="Next Verse">&gt;</button></div>
                
                <!-- Verse Tadabbur Section -->
                <div class="pt-6 border-t border-slate-200 rtl-content">
                    <div class="text-center mb-4">
                        <div class="flex items-center justify-center gap-4 mb-3">
                            <span class="text-sm text-slate-600" data-lang-key="modelSpeed">Model Speed:</span>
                            <div class="flex gap-2 bg-slate-100 rounded-lg p-1">
                                <button id="model-fast" class="model-btn px-4 py-1 rounded text-sm font-medium transition-colors active-model" data-model="fast">
                                    <span data-lang-key="fast">‚ö° Fast</span>
                                </button>
                                <button id="model-thinking" class="model-btn px-4 py-1 rounded text-sm font-medium transition-colors" data-model="thinking">
                                    <span data-lang-key="thinking">üß† Thinking</span>
                                </button>
                            </div>
                        </div>
                        <button id="gemini-btn" class="bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition-colors shadow-md" data-lang-key="deepenVerse"></button>
                    </div>
                    <div id="gemini-loader" class="hidden text-center mt-4"><div class="loader"></div><p class="text-slate-500" data-lang-key="contemplating"></p></div>
                    <div id="gemini-response" class="mt-4 p-6 bg-sky-50 rounded-lg border border-sky-200 text-slate-700 leading-relaxed hidden gemini-content"></div>
                </div>

                <!-- Exploration Tools Section -->
                <div class="mt-10 pt-6 border-t-2 border-dashed border-slate-300 rtl-content">
                    <h2 class="arabic-heading text-3xl text-center text-slate-700 mb-6" data-lang-key="explorationTools"></h2>
                    <div class="mb-8">
                        <label for="theme-input" class="block mb-2 text-lg font-bold text-slate-700" data-lang-key="thematicExploration"></label>
                        <div class="flex gap-2"><input type="text" id="theme-input" class="arabic-input w-full p-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500" data-lang-key="themePlaceholder"><button id="theme-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 transition-colors" data-lang-key="explore"></button></div>
                        <div id="theme-loader" class="hidden text-center mt-4"><div class="loader"></div><p class="text-slate-500" data-lang-key="exploring"></p></div>
                        <div id="theme-response" class="mt-4 p-4 bg-slate-50 rounded-lg border border-slate-200 hidden gemini-content"></div>
                    </div>
                    <div>
                        <label for="root-input" class="block mb-2 text-lg font-bold text-slate-700" data-lang-key="rootCompass"></label>
                        <div class="flex gap-2"><input type="text" id="root-input" class="arabic-input w-full p-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500" data-lang-key="rootPlaceholder"><button id="root-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 transition-colors" data-lang-key="analyze"></button></div>
                        <div id="root-loader" class="hidden text-center mt-4"><div class="loader"></div><p class="text-slate-500" data-lang-key="analyzing"></p></div>
                        <div id="root-response" class="mt-4 p-4 bg-slate-50 rounded-lg border border-slate-200 hidden gemini-content"></div>
                    </div>
                </div>

                 <!-- Daily Reflection Section -->
                <div class="mt-10 pt-6 border-t-2 border-dashed border-slate-300 rtl-content">
                    <div class="text-center">
                        <button id="daily-reflection-btn" class="bg-emerald-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-emerald-700 transition-colors shadow-lg text-lg" data-lang-key="dailyReflection"></button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        let quranCache = {}; 
        let fullMetadata = {};
        let selectedLanguage = 'en';
        let selectedModel = 'fast'; // 'fast' or 'thinking'
        let lastApiCallTime = 0; // Track last API call time for rate limiting
        const MIN_API_CALL_INTERVAL = 2000; // Minimum 2 seconds between calls
        let responseCache = {}; // Cache responses to avoid re-processing
        // Streaming Configuration
        // Set ENABLE_STREAMING to true to enable streaming responses (text appears as it's generated)
        // Set to false to use traditional non-streaming mode (wait for complete response)
        const ENABLE_STREAMING = true; // Set to false to use non-streaming mode
        const STREAMING_ENDPOINT = null; // Set to SSE endpoint URL if different from main endpoint
        
        /*
         * STREAMING SETUP INSTRUCTIONS:
         * 
         * Note: Google Apps Script Web Apps have limitations with true real-time streaming
         * because responses are buffered. For best results, consider:
         * 
         * Option 1: Direct Gemini API (Recommended for true streaming)
         * - Use Gemini API directly with streamGenerateContent()
         * - Set STREAMING_ENDPOINT to your streaming API URL
         * - This provides true real-time streaming
         * 
         * Option 2: Modified Google Apps Script (Limited streaming)
         * - Modify your Apps Script to return chunks in SSE format
         * - Note: Chunks may arrive in batches, not truly real-time
         * 
         * Example Google Apps Script modification:
         * 
         * function doPost(e) {
         *   const data = JSON.parse(e.parameter.data);
         *   const isStreaming = data.stream === true;
         *   
         *   if (isStreaming) {
         *     // Call Gemini with streaming
         *     const model = genai.getGenerativeModel({ model: "gemini-pro" });
         *     const result = model.generateContentStream(data.contents);
         *     
         *     let output = ContentService.createTextOutput();
         *     output.setMimeType(ContentService.MimeType.TEXT);
         *     
         *     for await (const chunk of result.stream) {
         *       const text = chunk.text();
         *       output.append('data: {"text": "' + text.replace(/"/g, '\\"') + '"}\n\n');
         *     }
         *     output.append('data: [DONE]\n\n');
         *     return output;
         *   }
         *   
         *   // Regular non-streaming response
         *   // ... existing code ...
         * }
         */
        
        // Simple hash function for cache keys to prevent collisions
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }

        // --- Translation Dictionary ---
        const translations = {
            en: { selectSurah: "Select Surah", selectVerse: "Select Verse", verse: "Verse", deepenVerse: "‚ú® Deepen Understanding of Verse", explorationTools: "Exploration Tools", thematicExploration: "Thematic Exploration", themePlaceholder: "e.g., Gratitude, Trust, Patience...", explore: "Explore", rootCompass: "Root-Word Compass", rootPlaceholder: "e.g., ÿ±ÿ≠ŸÖ, ŸÅŸÑÿ≠, ÿπŸÑŸÖ...", analyze: "Analyze", dailyReflection: "Receive a Daily Reflection", contemplating: "Contemplating...", exploring: "Exploring...", analyzing: "Analyzing...", loadingQuran: "Loading Qur'an data...", connectionError: "Connection Error", connectionErrorMsg: "Could not connect to the Qur'an libraries. Please check your internet connection and try again.", modelSpeed: "Model Speed:", fast: "‚ö° Fast", thinking: "üß† Thinking" },
            ar: { selectSurah: "ÿßÿÆÿ™ÿ± ÿßŸÑÿ≥Ÿàÿ±ÿ©", selectVerse: "ÿßÿÆÿ™ÿ± ÿßŸÑÿ¢Ÿäÿ©", verse: "ÿßŸÑÿ¢Ÿäÿ©", deepenVerse: "‚ú® ÿ™ÿØÿ®ÿ± ÿ£ÿπŸÖŸÇ ŸÑŸÑÿ¢Ÿäÿ©", explorationTools: "ÿ£ÿØŸàÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ŸÉÿ¥ÿßŸÅ", thematicExploration: "ÿ®ÿ≠ÿ´ ŸÖŸàÿ∂ŸàÿπŸä", themePlaceholder: "ŸÖÿ´ÿßŸÑ: ÿßŸÑÿµÿ®ÿ±ÿå ÿßŸÑÿ¥ŸÉÿ±ÿå ÿßŸÑÿ™ŸàŸÉŸÑ...", explore: "ÿßÿ≥ÿ™ŸÉÿ¥ŸÅ", rootCompass: "ÿ®ŸàÿµŸÑÿ© ÿßŸÑÿ¨ÿ∞ÿ±", rootPlaceholder: "ŸÖÿ´ÿßŸÑ: ÿ±ÿ≠ŸÖÿå ŸÅŸÑÿ≠ÿå ÿπŸÑŸÖ...", analyze: "ÿ≠ŸÑŸÑ", dailyReflection: "ÿßÿ≥ÿ™ŸÇÿ®ŸÑ ÿ™ÿØÿ®ÿ±Ÿãÿß ŸäŸàŸÖŸäŸãÿß", contemplating: "Ÿäÿ™ÿØÿ®ÿ±...", exploring: "Ÿäÿ≥ÿ™ŸÉÿ¥ŸÅ...", analyzing: "Ÿäÿ≠ŸÑŸÑ...", loadingQuran: "ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÇÿ±ÿ¢ŸÜ...", connectionError: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ", connectionErrorMsg: "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÖŸÉÿ™ÿ®ÿßÿ™ ÿßŸÑŸÇÿ±ÿ¢ŸÜ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™ ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.", modelSpeed: "ÿ≥ÿ±ÿπÿ© ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨:", fast: "‚ö° ÿ≥ÿ±Ÿäÿπ", thinking: "üß† ÿ™ŸÅŸÉŸäÿ±" }
        };

        // --- DOM Elements ---
        const surahSelect = document.getElementById('surah-select');
        const verseSelect = document.getElementById('verse-select');
        const arabicVerseEl = document.getElementById('arabic-verse');
        const englishVerseEl = document.getElementById('english-verse');
        const basmalahDisplay = document.getElementById('basmalah-display');
        const loadingStateEl = document.getElementById('loading-state');
        const errorStateEl = document.getElementById('error-state');
        const appContentEl = document.getElementById('app-content');
        const geminiBtn = document.getElementById('gemini-btn');
        const geminiLoader = document.getElementById('gemini-loader');
        const geminiResponseEl = document.getElementById('gemini-response');
        const nextVerseBtn = document.getElementById('next-verse-btn');
        const prevVerseBtn = document.getElementById('prev-verse-btn');
        const langEnBtn = document.getElementById('lang-en');
        const langArBtn = document.getElementById('lang-ar');
        const modelFastBtn = document.getElementById('model-fast');
        const modelThinkingBtn = document.getElementById('model-thinking');
        const themeInput = document.getElementById('theme-input');
        const themeBtn = document.getElementById('theme-btn');
        const themeLoader = document.getElementById('theme-loader');
        const themeResponse = document.getElementById('theme-response');
        const rootInput = document.getElementById('root-input');
        const rootBtn = document.getElementById('root-btn');
        const rootLoader = document.getElementById('root-loader');
        const rootResponse = document.getElementById('root-response');
        const dailyReflectionBtn = document.getElementById('daily-reflection-btn');

        // --- Backup API Configuration ---
        const QURAN_APIS = [
            { metaUrl: 'https://api.alquran.cloud/v1/meta', surahUrl: (num) => `https://api.alquran.cloud/v1/surah/${num}/editions/quran-uthmani,en.sahih`, parseMeta: (data) => data.data.surahs.references, parseSurah: (data) => ({ ...data.data[0], englishAyahs: data.data[1].ayahs }) }
        ];

        // --- Functions ---

        function setLanguage(lang) {
            selectedLanguage = lang;
            const langStrings = translations[lang];
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (langStrings[key]) {
                    if (el.tagName === 'INPUT') el.placeholder = langStrings[key];
                    else el.textContent = langStrings[key];
                }
            });
            langEnBtn.classList.toggle('active-lang', lang === 'en');
            langArBtn.classList.toggle('active-lang', lang === 'ar');
            document.documentElement.lang = lang;
            document.documentElement.dir = lang === 'ar' ? 'rtl' : 'ltr';
            if (Object.keys(fullMetadata).length > 0) {
                populateSurahDropdown();
                const currentSurahData = quranCache[surahSelect.value];
                if (currentSurahData) {
                    populateVerses(currentSurahData);
                    displayVerse(currentSurahData, parseInt(verseSelect.value));
                }
            }
        }
        
        function setLoading(isLoading) { loadingStateEl.classList.toggle('hidden', !isLoading); appContentEl.classList.toggle('hidden', isLoading); errorStateEl.classList.add('hidden'); }
        function showError() { loadingStateEl.classList.add('hidden'); appContentEl.classList.add('hidden'); errorStateEl.classList.remove('hidden'); }

        function populateSurahDropdown() {
            const currentVal = surahSelect.value;
            surahSelect.innerHTML = '';
            fullMetadata.forEach(surah => {
                const option = document.createElement('option');
                option.value = surah.number;
                option.textContent = selectedLanguage === 'ar' 
                    ? `${surah.number}. ${surah.name}`
                    : `${surah.number}. ${surah.englishName}`;
                surahSelect.appendChild(option);
            });
            surahSelect.value = currentVal || 1;
        }

        async function populateSurahList() {
            for (const api of QURAN_APIS) {
                try {
                    const response = await fetch(api.metaUrl);
                    if (!response.ok) throw new Error('API response not ok');
                    const data = await response.json();
                    fullMetadata = api.parseMeta(data);
                    populateSurahDropdown();
                    return;
                } catch (error) { console.warn(`Primary API for metadata failed, trying backup...`, error); }
            }
            showError();
        }

        async function getSurahData(surahNumber) {
            if (quranCache[surahNumber]) return quranCache[surahNumber];
            for (const api of QURAN_APIS) {
                try {
                    const response = await fetch(api.surahUrl(surahNumber));
                    if (!response.ok) throw new Error('API response not ok');
                    const data = await response.json();
                    const parsedData = api.parseSurah(data);
                    quranCache[surahNumber] = parsedData;
                    return parsedData;
                } catch (error) { console.warn(`Primary API for Surah ${surahNumber} failed, trying backup...`, error); }
            }
            showError(); return null;
        }

        function populateVerses(surahData) {
            const currentVal = verseSelect.value;
            verseSelect.innerHTML = '';
            surahData.ayahs.forEach(ayah => {
                const option = document.createElement('option');
                option.value = ayah.numberInSurah;
                option.textContent = `${translations[selectedLanguage].verse} ${ayah.numberInSurah}`;
                verseSelect.appendChild(option);
            });
            verseSelect.value = currentVal || 1;
        }

        function displayVerse(surahData, verseNumber) {
            const verseData = surahData.ayahs[verseNumber - 1];
            const englishVerseData = surahData.englishAyahs[verseNumber - 1];
            if (!verseData || !englishVerseData) return;
            
            let arabicText = verseData.text;
            let englishText = englishVerseData.text;
            const basmalahArabic = "ÿ®Ÿêÿ≥ŸíŸÖŸê Ÿ±ŸÑŸÑŸëŸéŸáŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸíŸÖŸéŸ∞ŸÜŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸêŸäŸÖŸê";
            
            const surahNum = surahData.number;
            if (surahNum > 1 && surahNum !== 9) {
                basmalahDisplay.classList.remove('hidden');
                if (verseNumber === 1 && arabicText.trim().startsWith(basmalahArabic)) {
                    arabicText = arabicText.replace(basmalahArabic, '').trim();
                }
            } else {
                basmalahDisplay.classList.add('hidden');
            }

            arabicVerseEl.textContent = arabicText;
            englishVerseEl.textContent = englishText;
            englishVerseEl.style.display = selectedLanguage === 'en' ? 'block' : 'none';

            verseSelect.value = verseNumber;
            geminiResponseEl.classList.add('hidden');
            geminiResponseEl.innerHTML = '';
            prevVerseBtn.disabled = verseNumber === 1;
            nextVerseBtn.disabled = verseNumber === surahData.numberOfAyahs;
        }
        
        // Helper function to format streaming text incrementally
        function formatStreamingText(text) {
            if (!text) return '';
            
            let html = text;
            
            // Step 1: Protect code blocks first (replace with placeholders)
            const codeBlocks = [];
            html = html.replace(/```([\s\S]*?)```/g, function(match, code) {
                const placeholder = `___CODE_BLOCK_${codeBlocks.length}___`;
                codeBlocks.push('<pre><code>' + code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</code></pre>');
                return placeholder;
            });
            
            // Step 2: Protect inline code
            const inlineCodes = [];
            html = html.replace(/`([^`]+)`/g, function(match, code) {
                const placeholder = `___INLINE_CODE_${inlineCodes.length}___`;
                inlineCodes.push('<code>' + code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</code>');
                return placeholder;
            });
            
            // Step 3: Escape HTML first (but code blocks are protected)
            html = html
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Step 4: Process lists (after escaping, so we match escaped patterns)
            const lines = html.split('\n');
            let inList = false;
            let listType = '';
            let processedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                // Match list items (accounting for escaped asterisks)
                const unorderedMatch = line.match(/^[\*\-\+] (.+)$/);
                const orderedMatch = line.match(/^\d+\. (.+)$/);
                
                if (unorderedMatch) {
                    if (!inList || listType !== 'ul') {
                        if (inList) {
                            processedLines.push('&lt;/' + listType + '&gt;');
                        }
                        processedLines.push('&lt;ul&gt;');
                        inList = true;
                        listType = 'ul';
                    }
                    processedLines.push('&lt;li&gt;' + unorderedMatch[1] + '&lt;/li&gt;');
                } else if (orderedMatch) {
                    if (!inList || listType !== 'ol') {
                        if (inList) {
                            processedLines.push('&lt;/' + listType + '&gt;');
                        }
                        processedLines.push('&lt;ol&gt;');
                        inList = true;
                        listType = 'ol';
                    }
                    processedLines.push('&lt;li&gt;' + orderedMatch[1] + '&lt;/li&gt;');
                } else {
                    if (inList) {
                        processedLines.push('&lt;/' + listType + '&gt;');
                        inList = false;
                        listType = '';
                    }
                    processedLines.push(line);
                }
            }
            
            if (inList) {
                processedLines.push('&lt;/' + listType + '&gt;');
            }
            
            html = processedLines.join('\n');
            
            // Step 5: Unescape list HTML tags (but keep content escaped)
            html = html.replace(/&lt;(ul|ol|li)&gt;/g, '<$1>');
            html = html.replace(/&lt;\/(ul|ol|li)&gt;/g, '</$1>');
            
            // Step 6: Restore code blocks and inline code (they're already escaped)
            codeBlocks.forEach((block, i) => {
                html = html.replace(`___CODE_BLOCK_${i}___`, block);
            });
            inlineCodes.forEach((code, i) => {
                html = html.replace(`___INLINE_CODE_${i}___`, code);
            });
            
            // Step 7: Process headers
            html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            
            // Step 8: Bold (**text** or __text__)
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            
            // Step 9: Italic (*text* or _text_)
            html = html.replace(/\*\*/g, '___BOLD_PLACEHOLDER___');
            html = html.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
            html = html.replace(/___BOLD_PLACEHOLDER___/g, '**');
            
            html = html.replace(/__/g, '___BOLD_PLACEHOLDER2___');
            html = html.replace(/_([^_\n]+?)_/g, '<em>$1</em>');
            html = html.replace(/___BOLD_PLACEHOLDER2___/g, '__');
            
            // Step 10: Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Step 11: Convert double newlines to paragraphs
            html = html.split('\n\n').map(para => {
                para = para.trim();
                if (!para) return '';
                // Don't wrap if it's already a block element
                if (/^<(h[1-6]|ul|ol|pre|code|p)/.test(para)) {
                    return para;
                }
                return '<p>' + para + '</p>';
            }).join('');
            
            // Step 12: Single newlines become <br>
            html = html.replace(/(<\/p>)\n(<p>)/g, '$1$2');
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }
        
        // Streaming version using Server-Sent Events (SSE) or ReadableStream
        async function callGeminiStreaming(prompt, loaderEl, responseEl, lang) {
            loaderEl.classList.remove('hidden');
            responseEl.classList.add('hidden');
            responseEl.innerHTML = '';
            responseEl.classList.remove('ltr-content', 'rtl-content');
            responseEl.classList.add(lang === 'ar' ? 'rtl-content' : 'ltr-content');
            
            let accumulatedText = '';
            const cacheKey = `${hashString(prompt)}_${lang}_${selectedModel}`;
            
            try {
                // Check cache first
                if (responseCache[cacheKey]) {
                    console.log("Using cached response");
                    const cachedText = responseCache[cacheKey];
                    responseEl.innerHTML = formatStreamingText(cachedText);
                    loaderEl.classList.add('hidden');
                    responseEl.classList.remove('hidden');
                    return;
                }
                
                const APPS_SCRIPT_URL = STREAMING_ENDPOINT || "https://script.google.com/macros/s/AKfycbxsZBDSAmLWTSl5l33yoCGyumtue0bWvDk3EBSapLFh5IdT5GJHy76L-TQoAXXwx5Oe/exec";
                
                // Rate limiting
                const now = Date.now();
                const timeSinceLastCall = now - lastApiCallTime;
                if (timeSinceLastCall < MIN_API_CALL_INTERVAL) {
                    const waitTime = MIN_API_CALL_INTERVAL - timeSinceLastCall;
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
                lastApiCallTime = Date.now();
                
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory, stream: true, modelType: selectedModel }; // Include model selection
                
                const response = await fetch(APPS_SCRIPT_URL, { 
                    method: 'POST', 
                    headers: { 
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: 'data=' + encodeURIComponent(JSON.stringify(payload))
                });
                
                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }
                
                // Read the streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let streamComplete = false;
                
                // Show response element immediately when first chunk arrives
                let firstChunkReceived = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    // Decode chunk and add to buffer
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process complete lines (SSE format: "data: {...}\n\n")
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // Keep incomplete line in buffer
                    
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (!trimmedLine) continue;
                        
                        // Handle SSE format: "data: {...}"
                        if (trimmedLine.startsWith('data: ')) {
                            const data = trimmedLine.slice(6).trim();
                            
                            // Check for completion marker
                            if (data === '[DONE]') {
                                streamComplete = true;
                                break;
                            }
                            
                            // Parse JSON data
                            try {
                                const parsed = JSON.parse(data);
                                
                                // Handle text chunks
                                if (parsed.text) {
                                    accumulatedText += parsed.text;
                                    
                                    // Show response on first chunk
                                    if (!firstChunkReceived) {
                                        firstChunkReceived = true;
                                        responseEl.classList.remove('hidden');
                                        loaderEl.classList.add('hidden');
                                    }
                                    
                                    // Update UI with formatted text
                                    responseEl.innerHTML = formatStreamingText(accumulatedText);
                                    
                                    // Auto-scroll to bottom to follow the stream
                                    responseEl.scrollTop = responseEl.scrollHeight;
                                } 
                                // Handle errors
                                else if (parsed.error) {
                                    throw new Error(parsed.error.message || JSON.stringify(parsed.error));
                                }
                            } catch (parseError) {
                                // If not valid JSON, try treating as plain text
                                if (data && data !== '[DONE]') {
                                    accumulatedText += data;
                                    if (!firstChunkReceived) {
                                        firstChunkReceived = true;
                                        responseEl.classList.remove('hidden');
                                        loaderEl.classList.add('hidden');
                                    }
                                    responseEl.innerHTML = formatStreamingText(accumulatedText);
                                }
                            }
                        }
                        // Handle non-SSE format (plain JSON lines)
                        else if (trimmedLine.startsWith('{')) {
                            try {
                                const parsed = JSON.parse(trimmedLine);
                                if (parsed.text) {
                                    accumulatedText += parsed.text;
                                    if (!firstChunkReceived) {
                                        firstChunkReceived = true;
                                        responseEl.classList.remove('hidden');
                                        loaderEl.classList.add('hidden');
                                    }
                                    responseEl.innerHTML = formatStreamingText(accumulatedText);
                                } else if (parsed.error) {
                                    throw new Error(parsed.error.message || JSON.stringify(parsed.error));
                                }
                            } catch (e) {
                                // Ignore parse errors for non-JSON lines
                            }
                        }
                    }
                    
                    if (streamComplete) break;
                }
                
                // Process any remaining buffer content
                if (buffer.trim() && !streamComplete) {
                    const trimmedBuffer = buffer.trim();
                    if (trimmedBuffer.startsWith('data: ')) {
                        const data = trimmedBuffer.slice(6).trim();
                        if (data !== '[DONE]') {
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.text) {
                                    accumulatedText += parsed.text;
                                }
                            } catch (e) {
                                // Ignore parse errors
                            }
                        }
                    }
                }
                
                // Final update and cache
                if (accumulatedText) {
                    responseEl.innerHTML = formatStreamingText(accumulatedText);
                    responseCache[cacheKey] = accumulatedText;
                } else {
                    throw new Error("No content received from stream");
                }
                
            } catch (error) {
                console.error("Streaming API Error:", error);
                const errorMessage = error.message.includes("Rate limit") 
                    ? "Rate limit exceeded. Please wait a moment before trying again."
                    : `Sorry, a reflection could not be generated at this time. ${error.message}`;
                responseEl.innerHTML = `<p class="text-red-500 text-center">${errorMessage}</p>`;
            } finally {
                loaderEl.classList.add('hidden');
                responseEl.classList.remove('hidden');
            }
        }
        
        async function callGemini(prompt, loaderEl, responseEl, lang) {
            // Use streaming if enabled
            if (ENABLE_STREAMING) {
                return await callGeminiStreaming(prompt, loaderEl, responseEl, lang);
            }
            
            loaderEl.classList.remove('hidden');
            responseEl.classList.add('hidden');
            try {
                // Check cache first - instant response for previously processed prompts
                // Use hash of full prompt + language + model to prevent collisions
                const cacheKey = `${hashString(prompt)}_${lang}_${selectedModel}`;
                if (responseCache[cacheKey]) {
                    console.log("Using cached response");
                    const cachedText = responseCache[cacheKey];
                    responseEl.innerHTML = formatStreamingText(cachedText);
                    responseEl.classList.remove('ltr-content', 'rtl-content');
                    responseEl.classList.add(lang === 'ar' ? 'rtl-content' : 'ltr-content');
                    loaderEl.classList.add('hidden');
                    responseEl.classList.remove('hidden');
                    return;
                }
                
                const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxsZBDSAmLWTSl5l33yoCGyumtue0bWvDk3EBSapLFh5IdT5GJHy76L-TQoAXXwx5Oe/exec";
                
                // Rate limiting: ensure minimum time between requests
                const now = Date.now();
                const timeSinceLastCall = now - lastApiCallTime;
                if (timeSinceLastCall < MIN_API_CALL_INTERVAL) {
                    const waitTime = MIN_API_CALL_INTERVAL - timeSinceLastCall;
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
                // Fix Bug 2: Update timestamp immediately after rate limit check to prevent race conditions
                lastApiCallTime = Date.now();
                
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory, modelType: selectedModel }; // Include model selection
                
                // Retry logic with exponential backoff
                const maxRetries = 3;
                let lastError;
                
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        
                        const response = await fetch(APPS_SCRIPT_URL, { 
                            method: 'POST', 
                            headers: { 
                                'Content-Type': 'application/x-www-form-urlencoded'
                            },
                            body: 'data=' + encodeURIComponent(JSON.stringify(payload))
                        });
                        
                        const responseText = await response.text();
                        let result;
                        try {
                            result = JSON.parse(responseText);
                        } catch (parseError) {
                            console.error("Failed to parse response:", responseText);
                            throw new Error("Invalid JSON response from server");
                        }
                        
                        // Check for rate limit error (429)
                        if (result.error && result.error.code === 429) {
                            const retryAfter = Math.min(1000 * Math.pow(2, attempt), 10000); // Exponential backoff, max 10s
                            if (attempt < maxRetries - 1) {
                                console.log(`Rate limit hit. Retrying in ${retryAfter}ms... (attempt ${attempt + 1}/${maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, retryAfter));
                                continue; // Retry
                            } else {
                                throw new Error("Rate limit exceeded. Please wait a moment and try again.");
                            }
                        }
                        
                        // Check for other errors in response body
                        if (result.error) {
                            throw new Error(result.error.message || JSON.stringify(result.error));
                        }
                        
                        // Check HTTP status independently - don't require result.error to exist
                        if (!response.ok) {
                            throw new Error(`API call failed with status: ${response.status}`);
                        }
                        
                        // Success - process response
                        if (result.candidates && result.candidates[0]?.content?.parts?.[0]) {
                            const text = result.candidates[0].content.parts[0].text;
                            
                            // Cache the response for instant future access
                            // Use hash of full prompt + language + model to prevent collisions
                            const cacheKey = `${hashString(prompt)}_${lang}_${selectedModel}`;
                            responseCache[cacheKey] = text;
                            
                            responseEl.innerHTML = formatStreamingText(text);
                            responseEl.classList.remove('ltr-content', 'rtl-content');
                            responseEl.classList.add(lang === 'ar' ? 'rtl-content' : 'ltr-content');
                            return; // Success, exit function
                        } else {
                            console.error("Unexpected response structure:", result);
                            throw new Error("Invalid response structure from API. Check console for details.");
                        }
                    } catch (error) {
                        lastError = error;
                        // If it's not a rate limit error or we've exhausted retries, break
                        if (error.message && !error.message.includes("Rate limit") && !error.message.includes("429")) {
                            break;
                        }
                        // For rate limit errors, continue retry loop
                        if (attempt === maxRetries - 1) {
                            break; // Last attempt failed
                        }
                    }
                }
                
                // If we get here, all retries failed
                throw lastError || new Error("Request failed after multiple attempts");
                
            } catch (error) {
                console.error("Gemini API Error:", error);
                const errorMessage = error.message.includes("Rate limit") 
                    ? "Rate limit exceeded. Please wait a moment before trying again."
                    : `Sorry, a reflection could not be generated at this time. ${error.message}`;
                responseEl.innerHTML = `<p class="text-red-500 text-center">${errorMessage}</p>`;
            } finally {
                loaderEl.classList.add('hidden');
                responseEl.classList.remove('hidden');
            }
        }

        function getMasterPrompt() {
            return `You are a specialized AI assistant for Tadabbur al-Qur'an. Your entire analysis MUST be based on the principle that the Qur'an explains itself. 
            **Quarantine Protocol:** Do NOT use any external sources (historical stories, Hadith, classical tafsir) as the primary basis for your explanation. You must build your understanding from the Qur'anic text alone.
            **Translation Mandate:** When the response language is English, every Arabic word or quoted verse MUST be immediately followed by its English translation in parentheses. For example: "The word ÿßŸÑÿ≠ŸÖÿØ (Al-Hamd)..." or "...as mentioned in 'ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖ' (In the name of Allah, the Entirely Merciful, the Especially Merciful)." This is crucial for reader comprehension.
            **Some Rules that You need to see the Text through:**
            1. Every root of the word is indicating one specific meaning but used in different facets & ways.
            2. The root Word can be used in the same way but indicate different facets of the meaning (e.g., the different meanings of 'ÿ∂ÿ±ÿ®').
            3. The root word can be placed into different morphological patterns (ÿ£Ÿàÿ≤ÿßŸÜ) which changes its direction but not its core meaning. Pay close attention to the specific pattern (Ÿàÿ≤ŸÜ), for example, the difference between ŸÅÿπŸÑÿßŸÜ (Fa'laan), ŸÅÿπŸäŸÑ (Fa'eel), and ŸÅÿπÿßŸÑ (Fa'aal).
            4. Take into consideration of depths of meaning including all facets of life (ŸÉÿ™ÿßÿ® ŸÖÿ´ÿßŸÜŸä - Depths & Dualistic in nature).
            5. Some verses are interconnected even if they are in different suras & make a web of a perfect map.
            6. There is no contradiction in the quran.
            7. There are different facets of the same subject.
            8. There are some letters which acts as words (e.g., ÿ® in ÿ®ÿ≥ŸÖ).
            9. The Quranic arabic is a language in itself & we are discovering the meaning from it by itself.
            10. Consider all the ways the root word comes in (e.g., ŸÖÿ≠ŸÖÿØÿå ÿ£ÿ≠ŸÖÿØÿå ŸÖÿ≠ŸÖŸàÿØ).
            11. ÿßŸÑŸÇÿ±ÿ¢ŸÜ ŸäŸÅÿ≥ÿ± ÿ®ÿπÿ∂Ÿá ÿ®ÿπÿ∂ÿß ŸàŸÑÿß ŸäŸÑÿ≤ŸÖ ŸÑŸÅŸáŸÖŸá ÿßŸÑŸÖÿπÿßÿ¨ŸÖ ÿßŸà ÿßŸÑÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ®ŸàŸä.
            12. The Quran has a lot of different subjects as Whole systems.
            13. The Quran also has a lot of metaphors & teachings through Stories.
            14. The Principle of Perspective and Voice (ŸÖŸÜÿ∏Ÿàÿ± ÿßŸÑŸÖÿ™ŸÉŸÑŸÖ ŸàÿßŸÑŸÖÿÆÿßÿ∑ÿ®): Always consider who is speaking (Allah, the Prophet, an angel, etc.) and to whom they are speaking (the believers, all of humanity, etc.) to understand the full context and depth of the message, & When God mentions himself as (ŸÜÿ≠ŸÜ) Consider that he is talking as Him & The Systems that he created(Universe) so there is difference when he says (ÿ£ŸÜÿß) & (ŸÜÿ≠ŸÜ).
            15. The Principle of Qur'anic Temporality (ÿ≤ŸÖŸÜŸäÿ© ÿßŸÑŸÇÿ±ÿ¢ŸÜ): Pay special attention to verb tenses.
            16. The Principle of the Two Worlds (ÿπÿßŸÑŸÖ ÿßŸÑÿ∫Ÿäÿ® ŸàÿπÿßŸÑŸÖ ÿßŸÑÿ¥ŸáÿßÿØÿ©) Coherent with the Duality nature of the Quran: Analyze how the verse unfolds through a Duality Perspective if You can see it.
            17. The Principle of Pairs and Opposites (ÿßŸÑÿ£ÿ≤Ÿàÿßÿ¨ ÿßŸÑŸÖÿ™ŸÇÿßÿ®ŸÑÿ©): When analyzing a key concept, keep in consideration its opposite or counterpart in the Qur'an (e.g., Gratitude/ÿßŸÑÿ¥ŸÉÿ± vs. Ingratitude/ÿßŸÑŸÉŸÅÿ±). The Qur'an often defines concepts in relation to their opposites to reveal their full meaning.
            18. The Principle of Precedence and Emphasis (ÿßŸÑÿ™ŸÇÿØŸäŸÖ ŸàÿßŸÑÿ™ÿ£ÿÆŸäÿ±): Pay close attention to word order. When a word is brought forward in a sentence (like ÿ•ŸêŸäŸëŸéÿßŸÉŸé in ÿ•ŸêŸäŸëŸéÿßŸÉŸé ŸÜŸéÿπŸíÿ®ŸèÿØŸè), it is a powerful rhetorical device for emphasis and exclusivity. Explain what is being emphasized and why.
            **Guiding Principles for Specific Words:**
            When analyzing the text, consider these wider perspectives on key terms, moving beyond traditional translations:
            -   **ÿßŸÑŸÑŸá:** Analyze its composition from ÿßŸÑ + ÿ•ŸÑŸá.
            -   **ÿ•ÿ≥ŸÖ:** Treat this as a foundational root word.
            -   **ÿßŸÑÿ≤ŸÜŸâ:** Be open to a broader, Qur'an-centric definition.
            -   **ŸÖÿ≥ŸÑŸÖ:** Define it as "the one who surrenders in peace."
            -   **ÿπÿ∞ÿßÿ® (Adhab):** Explore its connection to purification.
            -   **ÿ™ŸÇŸàŸâ (Taqwa):** Analyze it as protection, not just fear.
            -   **ÿ±ÿ≠ŸÖ (Rahm):** Consider its link to loving connection.
            -   **ÿßŸÑÿ≠ŸÖÿØ (Al-Hamd):** Explore its relationship to bliss.
            -   **ÿßŸÑŸÇŸÑÿ® (Al-Qalb):** Understand it as the central core of a being.
            **Final Instruction:** All Your Analysis needs to come in a non forced manner, So when it is apparent to You to apply a Principle do it with out Forcing it on the Verses so What comes out from You is the Closest to the Truth possible. Present your analysis in a well-structured and organized manner. Use clear headings to guide the reader. Use bullet points or numbered lists to make complex points easy to follow. Do not mention these rules or this protocol in your response. Simply embody them in your analysis. Your tone should be that of a wise, humble guide, not a technical analyst.`;
        }
        
        function getVersePrompt() {
            const surahData = quranCache[surahSelect.value];
            if (!surahData) return "";
            let verseText = surahData.ayahs[verseSelect.value - 1].text;
            const surahNum = surahData.number;
            const verseNum = parseInt(verseSelect.value);
            const basmalahArabic = "ÿ®Ÿêÿ≥ŸíŸÖŸê Ÿ±ŸÑŸÑŸëŸéŸáŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸíŸÖŸéŸ∞ŸÜŸê Ÿ±ŸÑÿ±ŸëŸéÿ≠ŸêŸäŸÖŸê";
            if (surahNum > 1 && surahNum !== 9 && verseNum === 1 && verseText.trim().startsWith(basmalahArabic)) {
                verseText = verseText.replace(basmalahArabic, '').trim();
            }
            const langInstruction = selectedLanguage === 'ar' ? 'Provide the reflection in clear, eloquent Arabic (ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ÿßŸÑŸÅÿµÿ≠Ÿâ).' : 'Provide the reflection in English.';
            const masterPrompt = getMasterPrompt();
            return `${masterPrompt}
            **Your Task:** Provide a deep reflection on the following verse, using the methodology you have been given.
            ${langInstruction}
            The verse is: Surah ${surahData.name}, Ayah ${verseSelect.value}, which reads: "${verseText}"`;
        }
        
        function getThemePrompt() {
            const theme = themeInput.value.trim();
            const langInstruction = selectedLanguage === 'ar' ? 'Provide the response in clear, eloquent Arabic.' : 'Provide the response in English.';
            const masterPrompt = getMasterPrompt();
            return `${masterPrompt}
            **Your Task:** The user wants to understand the theme of "${theme}" as a complete system from the Qur'an.
            Structure your response using the following headings:
            1.  **What is ${theme}?**
            2.  **Why is ${theme} important?**
            3.  **How to Practice ${theme}?**
            4.  **The Fruits of ${theme}:**
            5.  **The Consequences of Lacking ${theme}:**
            For each point, you MUST cite the relevant Qur'anic verses that support your analysis.
            ${langInstruction}`;
        }
        
        function getRootPrompt() {
            const word = rootInput.value.trim();
            const langInstruction = selectedLanguage === 'ar' ? 'Provide the response in clear, eloquent Arabic.' : 'Provide the response in English.';
            const masterPrompt = getMasterPrompt();
            return `${masterPrompt}
            **Your Task:** The user has provided the root or a word from it: "${word}".
            1.  **Identify the three-letter root (ÿßŸÑÿ¨ÿ∞ÿ±)**.
            2.  **Explain the core, intrinsic meaning** of this root.
            3.  **Systematically list the different derivative words** that appear in the Qur'an from this root.
            4.  For **each derivative**, provide one example verse.
            5.  Briefly explain how the derivative's meaning in the verse connects back to the core meaning of the root.
            ${langInstruction}`;
        }

        // --- Event Handlers ---
        async function getVerseReflection() {
            geminiBtn.disabled = true;
            await callGemini(getVersePrompt(), geminiLoader, geminiResponseEl, selectedLanguage);
            geminiBtn.disabled = false;
        }

        async function getThematicExploration() {
            if (!themeInput.value.trim()) return;
            themeBtn.disabled = true;
            await callGemini(getThemePrompt(), themeLoader, themeResponse, selectedLanguage);
            themeBtn.disabled = false;
        }
        
        async function getRootAnalysis() {
            if (!rootInput.value.trim()) return;
            rootBtn.disabled = true;
            await callGemini(getRootPrompt(), rootLoader, rootResponse, selectedLanguage);
            rootBtn.disabled = false;
        }
        
        async function getRandomVerse() {
            dailyReflectionBtn.disabled = true;
            setLoading(true);
            
            const randomSurahNum = Math.floor(Math.random() * 114) + 1;
            const surahData = await getSurahData(randomSurahNum);
            
            if (surahData) {
                const randomVerseNum = Math.floor(Math.random() * surahData.numberOfAyahs) + 1;
                surahSelect.value = randomSurahNum;
                populateSurahDropdown();
                populateVerses(surahData);
                verseSelect.value = randomVerseNum;
                displayVerse(surahData, randomVerseNum);
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
            
            setLoading(false);
            dailyReflectionBtn.disabled = false;
        }
        
        surahSelect.addEventListener('change', async (e) => {
            setLoading(true);
            const surahNumber = e.target.value;
            const surahData = await getSurahData(surahNumber);
            if (surahData) {
                populateVerses(surahData);
                displayVerse(surahData, 1);
            }
            setLoading(false);
        });
        verseSelect.addEventListener('change', (e) => {
            const surahData = quranCache[surahSelect.value];
            if(surahData) displayVerse(surahData, parseInt(e.target.value));
        });
        nextVerseBtn.addEventListener('click', () => {
            const surahData = quranCache[surahSelect.value];
            if(surahData) displayVerse(surahData, parseInt(verseSelect.value) + 1);
        });
        prevVerseBtn.addEventListener('click', () => {
            const surahData = quranCache[surahSelect.value];
            if(surahData) displayVerse(surahData, parseInt(verseSelect.value) - 1);
        });
        langEnBtn.addEventListener('click', () => setLanguage('en'));
        langArBtn.addEventListener('click', () => setLanguage('ar'));
        
        // Model selection handlers
        function setModel(modelType) {
            selectedModel = modelType;
            modelFastBtn.classList.toggle('active-model', modelType === 'fast');
            modelThinkingBtn.classList.toggle('active-model', modelType === 'thinking');
            // Clear cache when model changes to ensure fresh responses
            responseCache = {};
        }
        modelFastBtn.addEventListener('click', () => setModel('fast'));
        modelThinkingBtn.addEventListener('click', () => setModel('thinking'));
        
        geminiBtn.addEventListener('click', getVerseReflection);
        themeBtn.addEventListener('click', getThematicExploration);
        rootBtn.addEventListener('click', getRootAnalysis);
        dailyReflectionBtn.addEventListener('click', getRandomVerse);

        // --- Initial Load ---
        async function initializeApp() {
            setLoading(true);
            await populateSurahList();
            if (Object.keys(fullMetadata).length > 0) {
                const initialSurahData = await getSurahData(1);
                if (initialSurahData) {
                    surahSelect.value = 1; 
                    populateVerses(initialSurahData);
                    verseSelect.value = 1;
                    displayVerse(initialSurahData, 1);
                }
            }
            setLanguage('en');
            setLoading(false);
        }

        initializeApp();
    </script>
</body>
</html>
